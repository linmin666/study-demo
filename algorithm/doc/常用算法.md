## 常用算法

### 深度优先搜索

#### 1. 概念

​     <u>深度优先搜索</u>在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用<u>先入后出的栈</u>来实现，也可以通过与栈等价的<u>递归</u>来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。

​    深度优先搜索也可以用来<u>检查环路</u>：记录每个遍历过的节点的父节点，若一个节点被再次遍历且父节点不同，则说明有环。我们也可以用拓扑排序判断是否有环路，若最后存在入度不为0的点，则说明有环。

   有时我们可能需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这种做法叫做<u>状态记录或者记忆化</u>。

### 回溯法

#### 1. 概念

​	回溯法是优先搜索的一种特殊情况，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。

​    顾名思义，回溯算法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点(及其子节点)并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有 [修改当前节点状态]→[递归子节点] 的步骤，只是多了回溯的步骤，变成 [修改当前节点状态]→[递归子节点]→[回改当前节点状态]。

​      回溯法修改一般有两种情况，一种是修改最后一位输出，比如排列组合;一种是修改访问标 记，比如矩阵里搜字符串。

#### 2. 基本思想

   在包含的所有解的解空间数中，按照深度优先搜索的策略，从根节点出发深度搜索解空间数。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含，从该节点出发继续探索下去，如果该节点不包含问题的解，则逐层向其祖先节点回溯。

​    若使用回溯法求问题的所有解时，要回溯到根，且根节点的所有可行的子树都要已被搜索才结束。若使用回溯法求任意一个解时，只要搜索到问题的一个解就可以结束。

#### 3. 解题步骤

* 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解；
* 确定节点的扩展搜索规则；
* 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索；

#### 4. 举例





