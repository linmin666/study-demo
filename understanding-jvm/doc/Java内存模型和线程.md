## Java内存模型与线程
### Java内存模型
背景介绍
* 缓存一致性问题：为了解决处理器和存储设备间的速度差异，现代计算机系统引入了高速缓存，这带来了一个新的问题，也就是缓存一致性问题。
* 指令重排序：JVM的即时编译中，会对指令进行重排序的优化。

Java内存模型的主要目的是定义程序中各种变量（不包括局部变量与方法参数）的访问规则，关注在JVM中把变量值存储到内存和从内存中取出变量值的底层细节。
### 主内存与工作内存
Java内存模型规定了所有变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行。线程间变量值的传递均需要通过主内存来完成。
内存间交互操作。

Java内存模型定义了以下8种操作，用于主内存与工作内存间变量的值传递等操作。
* **lock**：作用于主内存的变量，把变量标识为线程独占状态；
* **unlock**：作用于主内存变量，释放lock状态的变量；
* **read**：作用于主内存变量，把变量值从主内存传输到线程的工作内存的变量副本中；
* **load**：作用于工作内存变量，把read操作得到的变量值放入工作内存的变量副本中；
* **use**：作用于工作内存变量，把工作内存中变量的值传递给执行引擎（当JVM遇到需要使用变量的值的字节码指令时会执行此操作）；
* **assign**：作用于工作内存变量，把从执行引擎接收到的值赋给工作内存中的变量（当JVM遇到给变量赋值的字节码指令时会执行此操作）；
* **store**：作用于工作内存变量，把工作内存中变量的值传递到主内存中，以便随后的write操作；
* **write**：作用于主内存变量，把store操作的变量值放入主内存的变量中；

对上述8种操作必须遵循如下规则：
* read和load、store和write操作都是成对出现的，不能只执行其中一个操作；
* 变量在工作内存中改变之后必须把该变化同步回主内存；
* 不允许线程无原因的（无assign操作）把数据从工作内存同步到主内存；
* 不允许在工作内存中直接使用一个未被初始化（load、assign）的变量；
* 一个变量同一时刻只能被一个线程lock，但该线程可以对其执行多次lock，只有执行相同次数的unlock，变量才会被解锁；
* 对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值；
* 若变量未被lock，那就不允许对它执行unlock，也不允许对其他线程lock的变量执行unlock；
* 对一个变量执行unlock之前，必须把它同步回主内存中；
### volatile的特殊规则
volatile修饰的变量具有以下两个特性：
1. 保证对所有线程的可见性
   当一个线程修改这个变量的值，新值对于其他线程来说是立即可知的。注意，volatile只保证可见性，但对volatile修饰的变量进行运算在并发情况下是不安全的（因为Java中的运算符操作并非原子操作）。举例：
```java  
   /**
* 如下代码
* 我们期待的结果是20*1000，但最后运行的结果可能是小于它的。这是因为race++操作不是一个原子操作。
  */
 public class VolatileTest {
    public static volatile int race = 0;

    public static void increase() {
        race++; //非原子操作
    }

    private static final int THREADS_COUNT = 20;

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADS_COUNT];
        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 1000; i++) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }
        //等待所有线程运行结束
        while (Thread.activeCount() > 2)
         Thread.yield();
        System.out.println(race);
    }
}

 ``` 
2. 禁止指令重排序 
   
   volatile修饰的变量在赋值后会多执行一个lock addl $0x0,(%esp) 操作，这个操作的作用相当于一个内存屏障。lock addl $0x0,(%esp) （把ESP寄存器的值加0）指令是一个空操作，作用是将本处理器的缓存写入内存，这个写入动作也会引起别的处理器或别的内核无效化其缓存，这个操作相当于对缓存中的变量做了一次store和write操作。
   
关于性能

volatile变量读操作的读操作的性能消耗和普通变量几乎没什么差别，写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。
   
### long和double的特殊规则
   Java内存模型中规定：允许虚拟机将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的操作来执行。对于目前主流的64位Java虚拟机，并不会出现非原子性访问行为，但对于32位的Java虚拟机，对long类型的数据存在非原子性访问的风险。
   线程安全特性
#### 1. 原子性
   Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。可以理解为，基本数据类型的访问、读写都是具备原子性的。若需要更大范围的原子性保证，可以使用lock和unlock操作（提供更高层次的字节码指令位monitorenter和monitorexit来隐式使用这两个操作），synchronized就是使用这两个字节码指令来实现的。
#### 2. 可见性
   可见性指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。volatile、sychronized、final关键字都满足可见性。
#### 3. 有序性
   Java提供volatile、sychronized来保证线程之间操作的有序性。 
   
### Happens-Before原则
   Happens-Before是Java内存模型中定义的两项操作之间的偏序关系。下面是Java内存模型下一些天然的Happens-Before关系：
1. **程序次序规则**：在一个线程内，按照控制流顺序（注意，不是程序代码顺序），书写在前面的操作先行发生于书写在后面的操作；
2. **管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作；
3. **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；
4. **线程启动规则**：Thread对象的start()方法先行发生于此线程的每一个动作；
5. **线程终止规则**：线程中所有操作都先行发生于对此线程的终止检测；
6. **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. **对象终结规则**：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始；
8. **传递性**：若A操作先行发生于B操作，B操作先行发生于C操作，那么A先行发生于C；
